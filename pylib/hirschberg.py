 #!/usr/bin/env python3

"""
hirschberg.py

Iterative bottom-up dynamic programming solution to longest common
subsequence problem with Hirschberg's contributions:
    (1) reduce length matrix to vector;
    (2) reduce to linear size storage.

Usage:
    python3 hirschberg.py

TODO:
    - TODO: debug ALG C: trace execution for a case
    - add profiling for time & space

"""

__author__ = "Maksim Yegorov"
__date__ = "2016-04-24 Sun 05:51 PM"

from profilers import len_recursion, time_profiler, registry
from generate_string import strgen

@time_profiler(repeat=1)
def lcs_hirschberg(seq1, seq2):
    """Calls helper function to calculate an LCS.

    Args:
        seq1 (string):  a random string sequence generated by
                        generate_string.strgen()
        seq2 (string):  another random string sequence like seq1
    Returns:
        LCS table

    """
    len1 = len(seq1)
    len2 = len(seq2)

    # for efficiency (see ALG B)
    # select min(|seq1|, |seq2|) for vector storage
    if len1 < len2:
        seq1, seq2 = seq2, seq1
        len1, len2 = len2, len1

    # if only the length of the LCS is required,
    # the matrix can be reduced to a min(m,n)+1 vector
    # as the dynamic programming approach only needs the
    # current and previous columns of the matrix.
    lcs_vector = [0 for j in range(len2+1)]
    _lcs_hirschberg(seq1, seq2, len1+1, len2+1,
                    lcs_vector)
    return lcs_vector


def _lcs_hirschberg(seq1, seq2, i, j, lcs_vector):
    """Iterative Hirschberg dynamic programming solution to
    LCS problem. See CLRS p.394.

    Args:
        seq1 (string):  a string sequence generated by
                            generate_string.strgen()
        seq2 (string):  another random string sequence
                            like seq1
        i (int):        number of rows in LCS table
                            (=len(seq1) + 1)
        j (int):        number of columns in LCS table
                            (=len(seq2) + 1)
        lcs_vector (1D list):   a vector of LCS length for
                                [i-1, j-1] prefix, as in ALG B
    Returns:
        None:    modifies in place LCS length table
    """

    for char in range(1, i):
        prev = 0
        for col in range(1, j):
            if seq1[char-1] == seq2[col-1]:
                tmp = prev
                prev = lcs_vector[col-1] + 1
                lcs_vector[col-1] = tmp
            elif lcs_vector[col] >= prev:
                lcs_vector[col-1] = prev
                prev = lcs_vector[col]
            else:
                lcs_vector[col-1] = prev
                # prev = prev
            if col == j - 1:
                lcs_vector[col] = prev

def algC(seq1, seq2):
    """Calls helper function to construct LCS."""

    m = len(seq1)
    n = len(seq2)

    if (m == 0 or n == 0):
        return ""

    # for efficiency (see ALG B)
    # select min(|seq1|, |seq2|) for vector storage
    if m < n:
        seq1, seq2 = seq2, seq1
        m, n = n, m

    lcs_arr = _algC(m, n, seq1, seq2)
    lcs = "".join(lcs_arr)
    return lcs

def _algC(m, n, seq1, seq2):
    """Implements Algorithm C by Hirschberg.

    Args:
        seq1 (str): sequence 1
        seq2 (str): sequence 2
        m (int): length of seq1
        n (int): length of seq2
    """
    if n == 0:
        print("n == 0, returning []")
        return []
    elif m == 1:
        if seq1[0] in seq2:
            print("m == 1: returning ["+str(seq1[0]) + "]")
            return [seq1[0]]
        else:
            print('m == 1: returning []')
            return []
    else:
        mid = m // 2

        lcs_vector_1 = [0 for j in range(n+1)]
        lcs_vector_2 = [0 for j in range(n+1)]

        _lcs_hirschberg(seq1[:mid], seq2, mid+1, n+1, lcs_vector_1)
        _lcs_hirschberg(seq1[:mid-1:-1], seq2[::-1],
                m-mid+1, n+1, lcs_vector_2)

        lcs_vector_1.insert(0,0)
        lcs_vector_2.insert(0,0)

        sums = [lcs_vector_1[i] + lcs_vector_2[n-i+1] for i in \
                range(len(lcs_vector_1))]

        #print("lcs vectors:")
        #print(str(lcs_vector_1))
        #print(str(lcs_vector_2))
        #print("sums = ", str(sums))

        k = sums.index(max(sums))
        #print("k = ", str(k))

        C1 = _algC(mid, min(k, n), seq1[:mid], seq2[:k])
        C2 = _algC(m-mid, n-min(k, n), seq1[mid:], seq2[k:])
        C1.extend(C2)
        print("general case, returning: " + str(C1))
        return C1

def size_lcs(lcs_vector):
    """Returns length of maximum common subsequence.

    Args:
        lcs_vector (1D list):   a vector of LCS length for
                                [i, j] prefix
    Returns:
        length (int):           LCS length
    """
    return lcs_vector[-1]


if __name__ == "__main__":
    """Tests and top-level logic go here."""

    sequence_1 = strgen(['a','b','c'], 100)
    sequence_2 = strgen(['a','b','c'], 100)
    #sequence_1 = "abcbdab"
    #sequence_2 = "bdcaba"
    print("seq1: %s" %sequence_1)
    print("seq2: %s" %sequence_2)

    name, elapsed, lcs_vector = \
            lcs_hirschberg(sequence_1, sequence_2)
    lcs_length = size_lcs(lcs_vector)
    recursion_depth = registry['_lcs_hirschberg']
    print("LCS length: %d" %lcs_length)


    #for row in lcs_vector:
    #    print(row)
    #print()

    #assert algC("", "") == ""
    #assert algC("", "123") == ""
    #assert algC("123", "") == ""
    #assert algC("abc", "123") == ""
    #assert algC("123", "123") == "123"
    #assert algC("bbcaba", "cbbbaab") == "bbba"
    print(algC("123", "123"))
    #print(algC("bbcaba", "cbbbaab"))




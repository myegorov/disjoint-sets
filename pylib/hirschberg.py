 #!/usr/bin/env python3

"""
hirschberg.py

Iterative bottom-up dynamic programming solution to longest common
subsequence problem with Hirschberg's contributions:
    (1) reduce length matrix to vector;
    (2) reduce to linear size storage.

Usage:
    python3 hirschberg.py

TODO:
    - implemented Hirschberg's ALG B
    - TODO: implement ALG C

"""

__author__ = "Maksim Yegorov"
__date__ = "2016-04-23 Sat 10:56 PM"

from profilers import len_recursion, time_profiler, registry
from generate_string import strgen

@time_profiler(repeat=1)
def lcs_hirschberg(seq1, seq2):
    """Calls helper function to calculate an LCS.

    Args:
        seq1 (string):  a random string sequence generated by
                        generate_string.strgen()
        seq2 (string):  another random string sequence like seq1
    Returns:
        LCS table

    """
    len1 = len(seq1)
    len2 = len(seq2)

    # for efficiency (see ALG B)
    # select min(|seq1|, |seq2|) for vector storage
    if len(seq1) < len(seq2):
        seq1, seq2 = seq2, seq1
        len1, len2 = len2, len1

    # if only the length of the LCS is required,
    # the matrix can be reduced to a min(m,n)+1 vector
    # as the dynamic programming approach only needs the
    # current and previous columns of the matrix.
    lcs_vector = [0 for j in range(len2+1)]
    _lcs_hirschberg(seq1, seq2, len1+1, len2+1,
                    lcs_vector)
    return lcs_vector


def _lcs_hirschberg(seq1, seq2, i, j, lcs_vector):
    """Iterative Hirschberg dynamic programming solution to
    LCS problem. See CLRS p.394.

    Args:
        seq1 (string):  a string sequence generated by
                            generate_string.strgen()
        seq2 (string):  another random string sequence
                            like seq1
        i (int):        number of rows in LCS table
                            (=len(seq1) + 1)
        j (int):        number of columns in LCS table
                            (=len(seq2) + 1)
        lcs_vector (1D list):   a vector of LCS length for
                                [i-1, j-1] prefix, as in ALG B
    Returns:
        None:    modifies in place LCS length table
    """

    for char in range(1, i):
        prev = 0
        for col in range(1, j):
            if seq1[char-1] == seq2[col-1]:
                tmp = prev
                prev = lcs_vector[col-1] + 1
                lcs_vector[col-1] = tmp
            elif lcs_vector[col] >= prev:
                lcs_vector[col-1] = prev
                prev = lcs_vector[col]
            else:
                lcs_vector[col-1] = prev
                # prev = prev
            if col == j - 1:
                lcs_vector[col] = prev

def size_lcs(lcs_vector):
    """Returns length of maximum common subsequence.

    Args:
        lcs_vector (1D list):   a vector of LCS length for
                                [i, j] prefix
    Returns:
        length (int):           LCS length
    """
    return lcs_vector[-1]


if __name__ == "__main__":
    """Tests and top-level logic go here."""

    sequence_1 = strgen(['a','b','c'], 100)
    sequence_2 = strgen(['a','b','c'], 100)
    #sequence_1 = "abcbdab"
    #sequence_2 = "bdcaba"
    print("seq1: %s" %sequence_1)
    print("seq2: %s" %sequence_2)

    name, elapsed, lcs_vector = \
            lcs_hirschberg(sequence_1, sequence_2)
    lcs_length = size_lcs(lcs_vector)
    recursion_depth = registry['_lcs_hirschberg']
    print("LCS length: %d" %lcs_length)


    #for row in lcs_vector:
    #    print(row)
    #print()

